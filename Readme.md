# WHAT IS IT?

This is an implementation of the algorithms proposed in the article [Dissecting the square into seven or nine congruent parts](https://arxiv.org/abs/2104.04940). We recommend reading it first.

The executables are provided on **Jupyter** notebooks that are divided in **search** and **proof** files. In the first files the main process is executed and in the second, the user can see a step by step explanation of what the deep search does for a given graph. To give a more detailed explanation of what these files do we use as example the square case. The notebooks for other variants (tiling a rectangule or using equiangular pieces) are similar but use the filters that fit their conditions. It is important to note that **joblib.Parallel** is used to paralelize the process.

## SEARCH FILES

The search files begin by loading the graphs generated by **plantri**:
``` python
Graphs7 = load_plantri(filename='plantri/12pm4c3')
print(f'Loaded {len(Graphs7)} grahps from plantri.')
```
The **plantri** files are not included in this repository since some of these are quite large. To see more about plantri and how to use it see the [documentation](https://users.cecs.anu.edu.au/~bdm/plantri/plantri-guide.txt).
\
The notebook continues by marking the distinguished vertices in each graph (some graphs could have more than one of these):
``` python
inputs = tqdm(Graphs7)
# add_distinguished is executed in each graph of Graphs7
if __name__ == "__main__":
    processed_list = Parallel(n_jobs=num_cores)(delayed(add_distinguished)(G) for G in inputs)
Graphs7 = [G for DGraph in processed_list for G in DGraph]
print(f'Constructed {len(Graphs7)} graphs with a distinguished vertex.')
```
After that, we check that condition 2 of Lemma 5 is fulfilled:
``` python
inputs = tqdm(Graphs7)
if __name__ == "__main__":
    processed_list = Parallel(n_jobs=num_cores)(delayed(first_filter)(G) for G in inputs)
Graphs7 = [Graphs7[i] for i in range(len(Graphs7)) if processed_list[i]]
print(f'There are {len(Graphs7)} graphs left after first filter.')
```
After that, the cases are separated in accordance with the number of sides of **T**:
``` python
inputs = tqdm(Graphs7)
if __name__ == "__main__":
    #here we are separating the graphs that could represent a tiling with a polygon with five sides.
    processed_list = Parallel(n_jobs=num_cores)(delayed(has_min_deg)(G,5) for G in inputs)
Graphs7_5 = [Graphs7[i] for i in range(len(Graphs7)) if processed_list[i]]
print(f'There are {len(Graphs7_5)} pentagonal graphs.')
```
For a four sides tiles, we apply a second filter:

``` python
inputs = tqdm(Graphs7)
if __name__ == "__main__":
    processed_list = Parallel(n_jobs=num_cores)(delayed(second_filter)(G) for G in inputs)
Graphs7_4 = [Graphs7[i] for i in range(len(Graphs7)) if processed_list[i]]
print(f'There are {len(Graphs7_4)} quadrilateral graphs left after second filter.')
save_data(Graphs7_4,'grahps/filtered_7_4.txt')
```
This is the function which checks that the Lemma 5 condition 3 is fulfilled.
\
In the final part, the deep search algorithm is applied over each remaining graph:
``` python
Graphs7_4 = load_data('filtered_7_4.txt')
#Here the possible labelings are generated
save_ang_perms(4,'4_perms.txt')
inputs = tqdm(Graphs7_4)
if __name__ == "__main__":
    processed_list = Parallel(n_jobs=num_cores)(delayed(search)(ig,G,'4_perms.txt') for ig,G in enumerate(inputs))
FinalNodes = [Nodes for Nodes in processed_list if len(Nodes)>0]
print(f'There are {len(FinalNodes)} graphs left after performing a deep search for each quadrilateral graph.')
```

## PROOF FILES

As mentioned before, you can generate a step by step explanation of what the deep search does for a given graph. These files starts once the preliminar filters have been applied just as in the search files. After that, a proof for a given graph is generated:
``` python
import random
save_ang_perms(4,'4_perms.txt')
Graphs5_4 = load_data('grahps/filtered_5_4.txt')
#Choose a random graph
ig=random.randrange(len(Graphs5_4))
print('Incidence graph',ig)
G=Graphs5_4[ig] 
G.draw()
search(ig,G,'4_perms.txt',PrintProof=True)
```
In the output, the current graph is drawn (not necessarily a planar drawing) and the proof follows. We recommend seeing a previously generated proof in one of these files. When a graph has possible equations to be realized, these equations are shown.

# NOTES ABOUT RESULTS

## EQUIANGULAR CASE

In the paper we mention that some graphs are not filtered by the algorithm but are unrealizable. Every graph that is not filtered can be found in the search files. We list the graphs that do not produce a valid tiling here, using its respective number assigned in search file:

<ul>
    <li>5 tiles, 3 sides: 510, 1298, 1586</li>
    <li>5 tiles, 4 sides: 6, 11, 60, 68, 72, 89, 91</li>
</ul> 
