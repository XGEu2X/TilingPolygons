# WHAT IS IT?

This is an implementation of the algorithms proposed in the article [Dissecting the square into seven or nine congruent parts](https://arxiv.org/abs/2104.04940). We recommend to read it first.

The executables are provided on **Jupyter** notebooks that are divided in **search** and **proof** files. In the first files the main process is executed and in the second, the user can see a step by step explanation of what the deep search does for a given graph. To give a more detailed explanation of what this files do we use as example the case in which we want to tile a square. The notebooks for other variants (tiling a rectangule and the equiangular) are similar but only using the filters that fits its conditions. It is important to note that **joblib.Parallel** is used to paralelize the process.

## SEARCH FILES

The search files start loading the graphs generated by **plantri**:
``` python
Graphs7 = load_plantri(filename='plantri/12pm4c3')
print(f'Loaded {len(Graphs7)} grahps from plantri.')
```
The **plantri** files are not included in this repository since some of these are too big. To see more about plantri and how to use it see the [documentation](https://users.cecs.anu.edu.au/~bdm/plantri/plantri-guide.txt).
\
The notebook continues with marking the distinguished vertices to each graph (some graphs could have more than one set of those):
``` python
inputs = tqdm(Graphs7)
# add_distinguished is executed in each graph of Graphs7
if __name__ == "__main__":
    processed_list = Parallel(n_jobs=num_cores)(delayed(add_distinguished)(G) for G in inputs)
Graphs7 = [G for DGraph in processed_list for G in DGraph]
print(f'Constructed {len(Graphs7)} graphs with a distinguished vertex.')
```
Just after that, we check that the Lemma 5 condition 2 is fulfilled:
``` python
inputs = tqdm(Graphs7)
if __name__ == "__main__":
    processed_list = Parallel(n_jobs=num_cores)(delayed(first_filter)(G) for G in inputs)
Graphs7 = [Graphs7[i] for i in range(len(Graphs7)) if processed_list[i]]
print(f'There are {len(Graphs7)} graphs left after first filter.')
```
After that, the cases are separated considering the number of sides of **T**:
``` python
inputs = tqdm(Graphs7)
if __name__ == "__main__":
    #here we are separating the graphs that could represent a tiling with a polygon with five sides.
    processed_list = Parallel(n_jobs=num_cores)(delayed(has_min_deg)(G,5) for G in inputs)
Graphs7_5 = [Graphs7[i] for i in range(len(Graphs7)) if processed_list[i]]
print(f'There are {len(Graphs7_5)} pentagonal graphs.')
```
Then, for a four sides tiles, we apply its respective filter:

``` python
inputs = tqdm(Graphs7)
if __name__ == "__main__":
    processed_list = Parallel(n_jobs=num_cores)(delayed(second_filter)(G) for G in inputs)
Graphs7_4 = [Graphs7[i] for i in range(len(Graphs7)) if processed_list[i]]
print(f'There are {len(Graphs7_4)} quadrilateral graphs left after second filter.')
save_data(Graphs7_4,'grahps/filtered_7_4.txt')
```
This is the function which checks that the Lemma 5 condition 3 is fulfilled.
\
In the last rows, the deep search algorithm is applied over each remaining graph:
``` python
Graphs7_4 = load_data('filtered_7_4.txt')
#Here the possible labelings are generated
save_ang_perms(4,'4_perms.txt')
inputs = tqdm(Graphs7_4)
if __name__ == "__main__":
    processed_list = Parallel(n_jobs=num_cores)(delayed(search)(ig,G,'4_perms.txt') for ig,G in enumerate(inputs))
FinalNodes = [Nodes for Nodes in processed_list if len(Nodes)>0]
print(f'There are {len(FinalNodes)} graphs left after performing a deep search for each quadrilateral graph.')
```

## PROOF FILES

As mentiones before in this notebooks you can generate a step by step explanation of what the deep search does for a given graph. These files starts with the preliminar filters been applied just as in the search files. After that row, there are rows to generate a proof for a given graph:
``` python
import random
save_ang_perms(4,'4_perms.txt')
Graphs5_4 = load_data('grahps/filtered_5_4.txt')
#Choose a random graph
ig=random.randrange(len(Graphs5_4))
print('Incidence graph',ig)
G=Graphs5_4[ig] 
G.draw()
search(ig,G,'4_perms.txt',PrintProof=True)
```
In the output, first a draw of the current graph (not necessarily planar) is showed and then the proof. We recommend to see a previously generated in one of these files. When a graph has possible equations to be realizable, these equations are shown.
